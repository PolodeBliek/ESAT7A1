import matplotlib.pyplot as plt
import numpy as np
import time
import pickle
from tqdm import tqdm
from PIL import Image

from sklearn.cluster import DBSCAN
start_time = time.time()

# list of lists
matrix = pickle.load(open("matrix_vr_annelies.pkl", "rb"))
# numpy array
matrix = np.array(matrix)
image = Image.fromarray(matrix)
image = image.resize(size=(426,758))
matrix = np.array(image)

print(type(matrix))
print(len(matrix))
print(len(matrix[0]))

matrix1 = [[1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1],
          [1, 0, 0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 1, 0, 0, 0, 1, 1]]
nb_columns = len(matrix[0])
nb_rows = len(matrix)
d = []


def matrix_to_coordinates():
    for row in range(nb_rows):
        for column in range(nb_columns):
            if matrix[row][column] == 1:
                d.extend(np.array([[row, column]]))


# -*- coding: utf-8 -*-
"""
This is a simple implementation of DBSCAN intended to explain the algorithm.
@author: Chris McCormick
"""


def MyDBSCAN(D, eps, MinPts):
    """
    Cluster the dataset `D` using the DBSCAN algorithm.

    MyDBSCAN takes a dataset `D` (a list of vectors), a threshold distance
    `eps`, and a required number of points `MinPts`.

    It will return a list of cluster labels. The label -1 means noise, and then
    the clusters are numbered starting from 1.
    """

    # This list will hold the final cluster assignment for each point in D.
    # There are two reserved values:
    #    -1 - Indicates a noise point
    #     0 - Means the point hasn't been considered yet.
    # Initially all labels are 0.
    labels = [0] * len(D)

    # C is the ID of the current cluster.
    C = 0

    # This outer loop is just responsible for picking new seed points--a point
    # from which to grow a new cluster.
    # Once a valid seed point is found, a new cluster is created, and the
    # cluster growth is all handled by the 'expandCluster' routine.

    # For each point P in the Dataset D...
    # ('P' is the index of the datapoint, rather than the datapoint itself.)
    for P in tqdm(range(0, len(D))):

        # Only points that have not already been claimed can be picked as new
        # seed points.
        # If the point's label is not 0, continue to the next point.
        if not (labels[P] == 0):
            continue

        # Find all of P's neighboring points.
        NeighborPts = regionQuery(D, P, eps)
        print("regionQuery found")

        # If the number is below MinPts, this point is noise.
        # This is the only condition under which a point is labeled
        # NOISE--when it's not a valid seed point. A NOISE point may later
        # be picked up by another cluster as a boundary point (this is the only
        # condition under which a cluster label can change--from NOISE to
        # something else).
        if len(NeighborPts) < MinPts:
            labels[P] = -1
            print("first if")
        # Otherwise, if there are at least MinPts nearby, use this point as the
        # seed for a new cluster.
        else:
            C += 1
            print("starting growing")
            growCluster(D, labels, P, NeighborPts, C, eps, MinPts)
            print("growcluster")

    # All data has been clustered!
    print(labels)
    print('Number of objects:', max(labels))
    return labels


def growCluster(D, labels, P, NeighborPts, C, eps, MinPts):
    """
    Grow a new cluster with label `C` from the seed point `P`.

    This function searches through the dataset to find all points that belong
    to this new cluster. When this function returns, cluster `C` is complete.

    Parameters:
      `D`      - The dataset (a list of vectors)
      `labels` - List storing the cluster labels for all dataset points
      `P`      - Index of the seed point for this new cluster
      `NeighborPts` - All of the neighbors of `P`
      `C`      - The label for this new cluster.
      `eps`    - Threshold distance
      `MinPts` - Minimum required number of neighbors
    """

    # Assign the cluster label to the seed point.
    labels[P] = C

    # Look at each neighbor of P (neighbors are referred to as Pn).
    # NeighborPts will be used as a FIFO queue of points to search--that is, it
    # will grow as we discover new branch points for the cluster. The FIFO
    # behavior is accomplished by using a while-loop rather than a for-loop.
    # In NeighborPts, the points are represented by their index in the original
    # dataset.
    i = 0
    while i < len(NeighborPts):

        # Get the next point from the queue.
        Pn = NeighborPts[i]

        # If Pn was labelled NOISE during the seed search, then we
        # know it's not a branch point (it doesn't have enough neighbors), so
        # make it a leaf point of cluster C and move on.
        if labels[Pn] == -1:
            labels[Pn] = C

        # Otherwise, if Pn isn't already claimed, claim it as part of C.
        elif labels[Pn] == 0:
            # Add Pn to cluster C (Assign cluster label C).
            labels[Pn] = C

            # Find all the neighbors of Pn
            PnNeighborPts = regionQuery(D, Pn, eps)
            print("region query while grow cluster")

            # If Pn has at least MinPts neighbors, it's a branch point!
            # Add all of its neighbors to the FIFO queue to be searched.
            if len(PnNeighborPts) >= MinPts:
                NeighborPts = NeighborPts + PnNeighborPts
                print("if in the grow cluster function")
            # If Pn *doesn't* have enough neighbors, then it's a leaf point.
            # Don't queue up it's neighbors as expansion points.
            # else:
            # Do nothing
            # NeighborPts = NeighborPts

        # Advance to the next point in the FIFO queue.
        i += 1

        # We've finished growing cluster C!
    # print("--- %s seconds ---grow" % (time.time() - start_time))


def regionQuery(D, P, eps):
    """
    Find all points in dataset `D` within distance `eps` of point `P`.

    This function calculates the distance between a point P and every other
    point in the dataset, and then returns only those points which are within a
    threshold distance `eps`.
    """
    neighbors = []

    # For each point in the dataset...
    for Pn in range(0, len(D)):

        # If the distance is below the threshold, add it to the neighbors list.
        if np.linalg.norm(D[P] - D[Pn]) < eps:
            # print(D[Pn])
            neighbors.append(Pn)
            # print(neighbors)

    # print("--- %s seconds ---quer" % (time.time() - start_time))
    return neighbors



#print(len(d))
# print("--- %s seconds to coord---" % (time.time() - start_time))
#MyDBSCAN(d, 1.5, 2)
matrix_to_coordinates()
db_default = DBSCAN(eps = 1.01, min_samples = 10).fit(matrix)
#print(db_default.labels_)
print("NUMBER OF OBJECTS:" ,max(db_default.labels_))
print("--- %s seconds ---" % (time.time() - start_time))
